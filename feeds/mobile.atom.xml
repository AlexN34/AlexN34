<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Alex's Home page - mobile</title><link href="https://AlexN34.github.io/" rel="alternate"></link><link href="https://AlexN34.github.io/feeds/mobile.atom.xml" rel="self"></link><id>https://AlexN34.github.io/</id><updated>2018-03-31T17:50:00+11:00</updated><entry><title>Java and OCR Text Reading with Android Vision API</title><link href="https://AlexN34.github.io/blog/2018/androidvision" rel="alternate"></link><published>2018-03-31T17:50:00+11:00</published><updated>2018-03-31T17:50:00+11:00</updated><author><name>Alex Nguyen</name></author><id>tag:alexn34.github.io,2018-03-31:/blog/2018/androidvision</id><summary type="html">&lt;p&gt;Tinkering with Java/Android -- one surefire way to consume an Easter weekend!&lt;/p&gt;</summary><content type="html">&lt;h2&gt;SpringBoot&lt;/h2&gt;
&lt;p&gt;Last weekend I spent a lot of time re-familiarising with Java - I've spent a lot of time in the Python space recently. &lt;/p&gt;
&lt;p&gt;I learned how to use &lt;a href="https://projects.spring.io/spring-boot/"&gt;SpringBoot&lt;/a&gt; for a take-home which required exposing an API on a Server connected to a MySQL backend and essentially writing a client to pretty print query results.&lt;/p&gt;
&lt;p&gt;The general approach was similar to &lt;code&gt;Flask&lt;/code&gt; in that there are provided annotations that route REST endpoints - you just need to route requests to the right functions and bob's your uncle. The package &lt;/p&gt;
&lt;p&gt;JSON structure/type conversion was somewhat magical -- where with &lt;code&gt;requests&lt;/code&gt; you parse data structures from strings/ints on raw JSON, using Springboot with &lt;code&gt;Jackson&lt;/code&gt; in Java provides somewhat implicit conversion. Instead, you make a class that represents your JSON object (though I thankfully didn't need it, nesting works by having wrapper classes made too) and the library handles parsing to the input Object types you require. In my case, I needed dates called as a String to be parsed into a Date - it handled with no fuss which was convenient.&lt;/p&gt;
&lt;p&gt;Still, I find myself preferring the ability to interact with objects in Python and the ability to simply &lt;code&gt;pip install&lt;/code&gt; &amp;amp; &lt;code&gt;import&lt;/code&gt; stuff instead of fiddling with &lt;code&gt;maven&lt;/code&gt; XML dependencies and plugins. I would say 50% of project time was dedicated to figuring out how to make my project &lt;code&gt;.jar&lt;/code&gt; files run from commandline the way they do within the &lt;code&gt;IntelliJ&lt;/code&gt; IDE!
That could be my fault for not knowing how to configure the IDE to output the right thing for me yet, but it was pretty frustrating.&lt;/p&gt;
&lt;h2&gt;Android&lt;/h2&gt;
&lt;p&gt;This Easter weekend I decided to scratch an itch that has been in my brain for some time - is there a library that provides streamed, locally processed text scanning for mobile app development? Essentially I wanted something in the vein of of a QR Code scanner library, without the need to take pictures to interact with the captured code. Also instead of a QR code, I wanted to manipulate arbitrary text (i.e. optical character recognition) I wanted it to work locally for performance reasons as well as offline functionality. &lt;/p&gt;
&lt;p&gt;Knowing nothing about computer vision, I wanted to find a library to help out with this - rough searching brought up the &lt;a href="https://codelabs.developers.google.com/codelabs/mobile-vision-ocr/"&gt;Google Vision APIs sample&lt;/a&gt;. I spent the better part of a day to find it seems to deliver what I was looking for (particularly the local processing part).&lt;/p&gt;
&lt;p&gt;I followed the introduction and slightly adapted the result to do further simple text parsing - at a glance it recognises printed text pretty well. I'm hoping to get the time to continue tinkering in the next couple months - I'm envisioning a conversion app I can use by hovering on the fly instead of repeatedly typing numbers into my phone's calculator. For anyone interested, the project currently lives &lt;a href="https://github.com/AlexN34/ocrconverter"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Docker&lt;/h2&gt;
&lt;p&gt;My docker (compose) file repo &lt;a href="https://github.com/AlexN34/dockerfiles"&gt;here&lt;/a&gt; has now amassed files for running JetBrains IDEs: IntelliJ IDEA, PyCharm and AndroidStudio (this counts, it's based on IntelliJ)! &lt;/p&gt;
&lt;p&gt;Each file took a lot longer than expected to set up because while they all use the same general structure for config storage, they're not &lt;em&gt;exactly&lt;/em&gt; the same. I kept getting tripped up by the fact that the path looks like &lt;code&gt;~/{IDE Name}{version}/&lt;/code&gt;; it changes with every resolution. I could probably make it general with symlinking something like &lt;code&gt;ln -s ~/.{IDE Name} {IDE Name}{version}&lt;/code&gt;in the Dockerfile that builds the image in the first place and forever keeping a singular named repo for &lt;code&gt;.{IDE Name}&lt;/code&gt;, but for now the files just code in the latest version number. &lt;/p&gt;
&lt;p&gt;One cool thing was that it's possible to get USB passthrough to the docker container (for debugging on device) simply by mounting the &lt;code&gt;/dev/usb&lt;/code&gt; folder (&lt;em&gt;everything&lt;/em&gt; is a file) in Linux. Won't work on Windows though as apparently usb passthrough &lt;a href="https://forums.docker.com/t/docker-for-windows-usb-support/38693/2"&gt;isn't yet supported&lt;/a&gt; which dampens the dream of crossplatform for now.&lt;/p&gt;</content><category term="android"></category><category term="mobile"></category><category term="apps"></category><category term="ocr"></category><category term="docker"></category></entry></feed>